//! # THIS IS WIP!
//!
//! This is a WIP library to easily annotate rust data structures and
//! translating them into NEAR events
//!
//! ## Design goals
//!
//! - Avoid the overhead of creating event types. Instead use dynamic types
//!   from `serde_json` and immediately serialize
//!
//! ## TODO
//!
//! - [x] Create event string from an event data log
//! - [x] Create event string from an event data vector (needs to be wrapped in
//!       tuple struct)
//! - [x] Replace generics with serde_json::Value
//! - [x] Support for deserialization for indexers
//!   - [x] Deserialization code mustn't be wasm'ed for size reasons
//!        (use feature-gating for this)
//! - [x] Doc comments
//! - [] Package documentation
//!     - [] Warning that for code size reasons, no features are enabled
//! - [] `emit_event` on the traits, but test for size bloat first
//! - [] remove panics/unwraps/expects that are not related to the standards
//! - [] use no_std
//! - [] use a lightweight serde clone
//! - [] using `try_from` for autogenerated deserialization?
//!

/// Annotate a struct as NEAR event data log. Data logs are constituents of a
/// Vector-shaped NEAR event data. See
/// [NFT events](https://nomicon.io/Standards/Tokens/NonFungibleToken/Event)
/// for examples.
pub use near_event_data_log_macro::near_event_data_log;
/// Annotate a struct as NEAR event data. See
/// [NEP-297](https://github.com/near/NEPs/blob/master/neps/nep-0297.md) for
/// more.
pub use near_event_data_macro::near_event_data;

/// Creates a proper event according to NEP-297. Mostly for internal use, yet
/// exposed for cases where constructing new structs and annotating them is not
/// desirable.
#[cfg(feature = "ser")]
pub fn serialize_from_value(
    standard: &str,
    version: &str,
    event: &str,
    data: serde_json::Value,
) -> String {
    let mut s = r#"EVENT_JSON:{"standard":""#.to_string();
    s.push_str(&standard.to_string());
    s.push_str(r#"","version":""#);
    s.push_str(&version.to_string());
    s.push_str(r#"","event":""#);
    s.push_str(&event.to_string());
    s.push_str(r#"","data":"#);
    s.push_str(&data.to_string());
    s.push('}');
    s
}

/// The reverse of `serialize_from_value`. Returns an event spec triplet, as
/// well as a `serde_json::Value` for the data.
#[cfg(feature = "de")]
pub fn partial_deserialize_event(
    event_json: &str,
) -> Option<(String, String, String, serde_json::Value)> {
    use std::str::FromStr;
    let event_json = event_json.strip_prefix("EVENT_JSON:").unwrap();
    let object = serde_json::Value::from_str(event_json.trim_start()).unwrap();

    let standard = object.get("standard")?.as_str()?.to_string();
    let version = object.get("version")?.as_str()?.to_string();
    let event = object.get("event")?.as_str()?.to_string();
    let data = object.get("data").unwrap();

    Some((standard, version, event, data.clone()))
}

#[cfg(all(test, feature = "de", feature = "ser"))]
mod tests {
    use near_sdk::serde::{Deserialize, Serialize};

    mod near_events {
        pub use crate::*;
    }
    use near_events::*;

    #[near_event_data_log(
        standard = "nepXXX",
        version = "1.0.0",
        event = "test_event"
    )]
    struct TestEventLogV1 {
        foo: String,
    }

    #[near_event_data(
        standard = "nepXXX",
        version = "1.0.0",
        event = "test_event"
    )]
    struct TestEventDataV1(Vec<TestEventLogV1>);
    #[near_event_data_log(
        standard = "nepXXX",
        version = "2.0.0",
        event = "test_event"
    )]
    struct TestEventLogV2 {
        bar: String,
    }

    #[near_event_data(
        standard = "nepXXX",
        version = "2.0.0",
        event = "test_event"
    )]
    struct TestEventDataV2(Vec<TestEventLogV2>);

    const EVENT_STR: &str = r#"EVENT_JSON:{"standard":"nepXXX","version":"1.0.0","event":"test_event","data":[{"foo":"bar"}]}"#;

    #[test]
    fn data_log_serializes() {
        let log = TestEventLogV1 {
            foo: "bar".to_string(),
        };
        assert_eq!(log.serialize_event(), EVENT_STR);
    }

    #[test]
    fn data_serializes() {
        let logs = TestEventDataV1(vec![TestEventLogV1 {
            foo: "bar".to_string(),
        }]);
        assert_eq!(logs.serialize_event(), EVENT_STR);
    }

    fn extract_inner_data(event_json: String) -> String {
        let (standard, version, event, data) =
            partial_deserialize_event(&event_json).unwrap();

        println!("({}, {}, {})", standard, version, event);
        match (standard.as_str(), version.as_str(), event.as_str()) {
            ("nepXXX", "1.0.0", "test_event") => {
                // go from JSON dynamic typing to rust static typing
                let data_v1: TestEventDataV1 =
                    serde_json::value::from_value(data).unwrap();
                // extract string from first log in data
                data_v1.0[0].foo.clone()
            }
            ("nepXXX", "2.0.0", "test_event") => {
                // go from JSON dynamic typing to rust static typing
                let data_v2: TestEventDataV2 =
                    serde_json::value::from_value(data).unwrap();
                // extract string from first log in data
                data_v2.0[0].bar.clone()
            }
            (s, v, e) => {
                panic!("Got an unexpected event triplet: ({}, {}, {})", s, v, e)
            }
        }
    }

    #[test]
    fn deserialization() {
        let event_v1 = TestEventLogV1 {
            foo: "bar".to_string(),
        }
        .serialize_event();
        let event_v2 = TestEventLogV2 {
            bar: "baz".to_string(),
        }
        .serialize_event();

        assert_eq!(extract_inner_data(event_v1), "bar");
        assert_eq!(extract_inner_data(event_v2), "baz");
    }
}
